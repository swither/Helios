//  Copyright 2014 Craig Courtney
//  Copyright 2020 Ammo Goettsch
//  Copyright 2020 Helios Contributors
//    
//  Helios is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  Helios is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

using GadrocsWorkshop.Helios.Interfaces.DCS.Soft;
using GadrocsWorkshop.Helios.UDPInterface;
using GadrocsWorkshop.Helios.Util;
using GadrocsWorkshop.Helios.Util.DCS;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace GadrocsWorkshop.Helios.Interfaces.DCS.Common
{
    /// <summary>
    /// Supported export module formats
    ///
    /// WARNING: the string representatio of these are used in the export protocol and must never be changed except by addition of new codes
    /// </summary>
    public enum DCSExportModuleFormat
    {
        [Description("Helios driver generated by this interface")]
        HeliosDriver16,

        [Description("Export module provided by Capt Zeen (Version 1)")]
        CaptZeenModule1,

        // Description attribute: display string for use in UI
        [Description("Basic telemetry only")]
        TelemetryOnly
    }

    /// <summary>
    /// This object represents two related concepts:
    /// - Site configuration for the connection between the export script and Helios (IP address, port,
    /// update rate, which files are generated and where they are placed, etc.)
    /// - Generation of export files from a particular interface object
    /// These two aspects are not decoupled, because when used as a configuration object, it
    /// constantly recomputes the export files to see if they need to be regenerated.  So any attempt
    /// to separate the export file generation from the configuration object is of limited use.
    /// </summary>
    public class DCSExportConfiguration : DCSConfiguration
    {
        private static readonly NLog.Logger Logger = NLog.LogManager.GetCurrentClassLogger();

        public class ModuleFormatInfo
        {
            public string DisplayName { get; set; }
            public string ModuleLocation { get; set; }
            public bool CanBeAttached { get; set; }
            public bool CanGenerate { get; set; }

            // XXX try to replace with just can't attach and can't generate
            public bool UsesModuleFile { get; set; } = true;

            // inferences
            public bool IsAllowedToWrite => CanGenerate || CanBeAttached;
        }

        public readonly Dictionary<DCSExportModuleFormat, ModuleFormatInfo> ExportModuleFormatInfo =
            new Dictionary<DCSExportModuleFormat, ModuleFormatInfo>
            {
                {
                    DCSExportModuleFormat.HeliosDriver16, new ModuleFormatInfo
                    {
                        // capitalization for use in a sentence (not at the beginning)
                        DisplayName = "Helios driver generated by this interface",
                        ModuleLocation = "Drivers",
                        CanBeAttached = false,
                        CanGenerate = true
                    }
                },
                {
                    DCSExportModuleFormat.CaptZeenModule1, new ModuleFormatInfo
                    {
                        // capitalization for use in a sentence (not at the beginning)
                        DisplayName = "export module provided by Capt Zeen (Version 1)",
                        ModuleLocation = "Mods",
                        CanBeAttached = true,
                        CanGenerate = false
                    }
                },
                {
                    DCSExportModuleFormat.TelemetryOnly, new ModuleFormatInfo
                    {
                        // capitalization for use in a sentence (not at the beginning)
                        DisplayName = "basic telemetry driver",
                        // WARNING: although we don't generate drivers, this must be a real path because we use this setting to create the directory tree
                        ModuleLocation = "Drivers",
                        CanBeAttached = false,
                        CanGenerate = false
                    }
                }
            };

        // the main export script we generate
        private const string EXPORT_MAIN_NAME = "HeliosExport16.lua";

        // regex used to check for the call to our main exports already being present
        private static readonly Regex ExportMainCall = new Regex($"^\\s*dofile\\(.*{EXPORT_MAIN_NAME}.]?\\)", RegexOptions.Compiled | RegexOptions.Multiline);

        // regex used to check for a Capt Zeen style Export.lua from 1.4
        private static readonly Regex HeliosExport14Call = new Regex($"dofile\\(.*HeliosExport\\.lua.]?\\)", RegexOptions.Compiled);

        // regex used to check for a non trivial Export.lua that registers its own handlers
        private static readonly Regex LuaExportStartCall = new Regex("^\\s*(function\\s+)?LuaExportStart", RegexOptions.Compiled | RegexOptions.Multiline);

        // regex used to check for dofile calls in Export.lua
        private static readonly Regex DofileCall = new Regex("^\\s*[^-].*dofile\\(.*\\)", RegexOptions.Compiled | RegexOptions.Multiline);

        // regex used to check for Helios-generated third-party dofile calls in Export.lua
        private static readonly Regex HeliosDofileCall = new Regex("helios_dofile_.*result = pcall\\(dofile", RegexOptions.Compiled | RegexOptions.Multiline);

        // the interface that owns this object, and for which we generate the Exports
        private readonly DCSInterface _parent;

        /// <summary>
        /// full Lua contents of Export.lua stub we sometimes install
        /// </summary>
        private string _exportStub = "";

        /// <summary>
        /// full Lua contents of EXPORT_SCRIPT_NAME
        /// </summary>
        private string _exportMain = "";

        /// <summary>
        /// full Lua contents of module for _parent
        /// </summary>
        private string _exportModuleText = "";

        /// <summary>
        /// full Lua contents of module Impersonation
        /// </summary>
        private string _exportImpersonationModuleText = "";

        /// <summary>
        /// IP address to which Export.lua will send UDP updates
        /// </summary>
        private string _ipAddress;

        /// <summary>
        /// Export.lua update ticks per second
        /// </summary>
        private int _exportFrequency;

        /// <summary>
        /// backing field for property CanAttachModuleFile, contains
        /// true if a module of the currently selected ExportModuleFormat can be attached
        /// </summary>
        private bool _canAttachModuleFile;

        /// <summary>
        /// backing field for property SelectedModuleFile, contains
        /// full path of the file selected for serialization into the attached module text
        /// </summary>
        private string _selectedModuleFile;

        /// <summary>
        /// backing field for property ModuleFolderGuess, contains
        /// our best guess for the folder where the module we might want to attach would be located
        /// </summary>
        private string _moduleFolderGuess;

        /// <summary>
        /// backing field for property Status, contains
        /// the status of the configuration, including up to date, out of date, or lack of locations
        /// </summary>
        private StatusCodes _status;
        
        /// <summary>
        /// backing field for property ExportLuaHandling, contains
        /// selected mode for Export.lua stub configuration
        /// </summary>
        private ExportFileHandling _exportLuaHandling;

        public DCSExportConfiguration(DCSInterface parent)
        {
            _parent = parent;

            // get global configuration parameters that are not serialized to the profile
            _ipAddress = _parent.LoadSetting("IPAddress", System.Net.IPAddress.Loopback.ToString());
            _exportFrequency = _parent.LoadSetting("ExportFrequency", 30);
            _exportModuleText = _parent.ExportModuleText;

            // load dofiles settings first, because we may need that for upgrade 
            string savedDoFiles = _parent.LoadSetting("DoFiles", "");
            foreach (string file in savedDoFiles.Split(','))
            {
                if (!string.IsNullOrWhiteSpace(file))
                {
                    DoFiles.Add(file);
                }
            }

            if (_parent.HasSetting("ExportLuaHandling"))
            {
                _exportLuaHandling = _parent.LoadSetting("ExportLuaHandling", ExportFileHandling.Update);
            }
            else
            {
                // try to infer settting from legacy configuration
                CalculateExportLuaHandling();
            }
        }

        /// <summary>
        /// deferred initialization to be called after caller customizes the settings of this object
        /// </summary>
        public void Initialize()
        {
            // create our current config for status reporting
            UpdateConfiguration();

            // view model updates (this class provides simple view model support)
            UpdateViewModel();

            // register for changes:

            // if the UI changes our collection of dofiles, we recompute the exports
            DoFiles.CollectionChanged += DoFiles_CollectionChanged;

            // we recompute the exports if the collection of functions in our interface ever changes, in case there are any dynamic interfaces that change functions
            _parent.Functions.CollectionChanged += Functions_CollectionChanged;

            // location changes require us to recompute
            SubscribeToLocationChanges();

            // some properties in our parent object are relevant to us
            _parent.PropertyChanged += Parent_PropertyChanged;
        }

        private void CalculateExportLuaHandling()
        {
            // upgrade from previous version's configuration
            bool generateExportLoader = _parent.LoadSetting("GenerateExportLoader", true);
            if (generateExportLoader)
            {
                // only overwrite if we have dofile lines configured
                _exportLuaHandling = DoFiles.Any() ? ExportFileHandling.Replace : ExportFileHandling.Update;
            }
            else
            {
                // we were configured to ignore the Export.lua file
                _exportLuaHandling = ExportFileHandling.Ignore;
            }

            // write this here instead of setting the property, because we don't want to notify
            _parent.SaveSetting("ExportLuaHandling", _exportLuaHandling);
        }

        private void Parent_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            switch (e.PropertyName)
            {
                case "ExportModuleFormat":
                case "ExportModuleBaseName":
                    Update();
                    break;
                case "ExportModuleText":
                    // we receive this indirectly like this in case change is from undo
                    _exportModuleText = _parent.ExportModuleText;
                    Update();
                    break;
            }
        }

        public override void Dispose()
        {
            base.Dispose();
            DoFiles.CollectionChanged -= DoFiles_CollectionChanged;
            _parent.Functions.CollectionChanged -= Functions_CollectionChanged;
        }

        private void DoFiles_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // persist all children in changed collection to a single string
            _parent.SaveSetting("DoFiles", string.Join(",", DoFiles));
            Update();
        }

        private void Functions_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // some bound functions in our interface have changed
            Update();
        }

        #region Properties

        /// <summary>
        /// true if a module of the currently selected ExportModuleFormat can be attached
        /// REVISIT: this is really part of view model
        /// </summary>
        public bool CanAttachModuleFile
        {
            get => _canAttachModuleFile;
            set
            {
                if (_canAttachModuleFile == value)
                {
                    return;
                }

                bool oldValue = _canAttachModuleFile;
                _canAttachModuleFile = value;
                OnPropertyChanged("CanAttachModuleFile", oldValue, value, true);
            }
        }

        /// <summary>
        /// full path of the file selected for serialization into the attached module text
        /// </summary>
        public string SelectedModuleFile
        {
            get => _selectedModuleFile;
            set
            {
                if (_selectedModuleFile != null && _selectedModuleFile == value) return;
                string oldValue = _selectedModuleFile;
                _selectedModuleFile = value;
                if (value != null)
                {
                    // best guess if we try again is the same location
                    ModuleFolderGuess = Path.GetDirectoryName(value);

                    // try to read the file and include it
                    string moduleText = DCSInterface.NormalizeLineEndings(FileUtility.ReadFile(value));
                    using (new HeliosUndoBatch())
                    {
                        _parent.SetEmbeddedModule(value, moduleText);
                    }
                }
                else
                {
                    using (new HeliosUndoBatch())
                    {
                        _parent.RemoveEmbeddedModule();
                    }
                }
                OnPropertyChanged("SelectedModuleFile", oldValue, value, true);
            }
        }

        /// <summary>
        /// Export.lua update ticks per second
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public int ExportFrequency
        {
            get => _exportFrequency;
            set
            {
                if (!_exportFrequency.Equals(value))
                {
                    int oldValue = _exportFrequency;
                    _exportFrequency = value;
                    _parent.SaveSetting("ExportFrequency", _exportFrequency);
                    OnPropertyChanged("ExportFrequency", oldValue, value, true);
                }
            }
        }

        /// <summary>
        /// Relative paths to files that Export.lua will call via dofile(...)
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public ObservableCollection<string> DoFiles { get; } = new ObservableCollection<string>();

        /// <summary>
        /// IP address to which Export.lua will send UDP updates
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public string IPAddress
        {
            get => _ipAddress;
            set
            {
                if (_ipAddress == null && value != null
                    || _ipAddress != null && !_ipAddress.Equals(value))
                {
                    string oldValue = _ipAddress;
                    _ipAddress = value;
                    _parent.SaveSetting("IPAddress", _ipAddress);
                    OnPropertyChanged("IPAddress", oldValue, value, false);
                }
            }
        }

        /// <summary>
        /// Port number to which Export.lua will send UDP updates
        /// This is a site-specific setting persisted in HeliosSettings instead of in the profile.
        /// </summary>
        public int Port
        {
            // we want Export.lua to send to our listening port
            get => _parent.Port;
            set
            {
                int oldValue = _parent.Port;
                if (!oldValue.Equals(value))
                {
                    _parent.Port = value;
                    _parent.SaveSetting("Port", value);
                    OnPropertyChanged("Port", oldValue, value, false);
                }
            }
        }

        /// <summary>
        /// our best guess for the folder where the module we might want to attach would be located
        /// REVISIT: this is really part of view model
        /// </summary>
        public string ModuleFolderGuess
        {
            get => _moduleFolderGuess;
            set
            {
                if (_moduleFolderGuess != null && _moduleFolderGuess == value) return;
                string oldValue = _moduleFolderGuess;
                _moduleFolderGuess = value;
                OnPropertyChanged("ModuleFolderGuess", oldValue, value, true);
            }
        }

        /// <summary>
        /// the status of the configuration, including up to date, out of date, or lack of locations
        /// REVISIT: this is really part of view model
        /// </summary>
        public StatusCodes Status
        {
            get => _status;
            set
            {
                if (_status == value) return;
                StatusCodes oldValue = _status;
                _status = value;
                OnPropertyChanged("Status", oldValue, value, true);
            }
        }

        /// <summary>
        /// selected mode for Export.lua stub configuration
        /// </summary>
        public ExportFileHandling ExportLuaHandling
        {
            get => _exportLuaHandling;
            set
            {
                if (_exportLuaHandling == value) return;
                ExportFileHandling oldValue = _exportLuaHandling;
                _exportLuaHandling = value;
                _parent.SaveSetting("ExportLuaHandling", value);
                OnPropertyChanged("ExportLuaHandling", oldValue, value, true);

                _parent.InvalidateStatusReport();
            }
        }

        #endregion

        // view model functionality is embedded in this model class
        private void UpdateViewModel()
        {
            IList<InstallationLocation> locations = InstallationLocations.Singleton.Active;
            if (locations.Any())
            {
                // update this the guess if we can, otherwise just keep any guess we already might have
                ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
                ModuleFolderGuess = locations.First().ExportModuleDirectory(moduleInfo.ModuleLocation);
            }
            CanAttachModuleFile = ExportModuleFormatInfo[_parent.ExportModuleFormat].CanBeAttached;
        }

        private void UpdateConfiguration()
        {
            // reconfigure everything
            UpdateDirectories();
            UpdateExportStub();
            UpdateExportScript();
            UpdateModule();
        }

        protected override void Update()
        {
            UpdateConfiguration();
            UpdateViewModel();
            _parent.InvalidateStatusReport();
        }

        /// <summary>
        /// main entry point to write all generated files
        /// </summary>
        /// <returns>true if everything was written without error</returns>
        public override InstallationResult Install(IInstallationCallbacks callbacks)
        {
            try
            {
                ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
                List<StatusReportItem> report = new List<StatusReportItem>();

                // pass1: get permissions
                HashSet<string> considered = new HashSet<string>();
                foreach (InstallationLocation location in InstallationLocations.Singleton.Active)
                {
                    if (!AuthorizeExportStubChanges(callbacks, considered, location))
                    {
                        return InstallationResult.Canceled;
                    }
                }

                // pass2: do the writes
                foreach (InstallationLocation location in InstallationLocations.Singleton.Active)
                {
                    // create deepest folder
                    if (!Directory.Exists(location.ExportModuleDirectory(moduleInfo.ModuleLocation)))
                    {
                        Directory.CreateDirectory(location.ExportModuleDirectory(moduleInfo.ModuleLocation));
                    }

                    // actually modify the file if we have to
                    InstallExportStub(location, report);

                    // main export script is required
                    File.WriteAllText(location.ExportMainPath(EXPORT_MAIN_NAME), _exportMain);
                    report.Add(new StatusReportItem
                    {
                        Status = $"Wrote main export file {EXPORT_MAIN_NAME} to {location.SavedGamesName}",
                        Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                    });

                    if (string.IsNullOrEmpty(_exportModuleText) || !moduleInfo.IsAllowedToWrite)
                    {
                        // not embedded module, we are done
                        continue;
                    }

                    string baseName = _parent.WrittenModuleBaseName;
                    File.WriteAllText(
                        location.ExportModulePath(moduleInfo.ModuleLocation, baseName),
                        _exportModuleText);
                    report.Add(new StatusReportItem
                    {
                        Status = $"Wrote {moduleInfo.DisplayName} for {baseName} to {location.SavedGamesName}",
                        Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                    });

                    if(_parent is SoftInterface softInterface && softInterface.ImpersonatedVehicles.Count() > 1 && !softInterface.ImpersonatedVehicles.Contains(softInterface.Name))
                    {
                        foreach (string vehicle in softInterface.ImpersonatedVehicles)
                        {
                            File.WriteAllText(
                                location.ExportModulePath(moduleInfo.ModuleLocation, vehicle),
                                _exportImpersonationModuleText);
                            report.Add(new StatusReportItem
                            {
                                Status = $"Wrote {moduleInfo.DisplayName} for {vehicle} - {baseName} to {location.SavedGamesName}",
                                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                            });
                        }
                    }
                }

                // update status after all writes
                Update();
                callbacks.Success("Configuration of exports succeeded",
                    "All configured DCS locations were updated with Export.lua and all related scripts", report);
                return InstallationResult.Success;
            }
            catch (Exception ex)
            {
                Logger.Error(ex, "Failed to write DCS Export scripts due to error");
                callbacks.Failure("Failed to write DCS Export scripts due to error", ex.StackTrace,
                    new List<StatusReportItem>());
                return InstallationResult.Fatal;
            }
        }

        private void InstallExportStub(InstallationLocation location, List<StatusReportItem> report)
        {
            if (ExportLuaHandling == ExportFileHandling.Ignore)
            {
                // nothing to do
                report.Add(new StatusReportItem
                {
                    Status = $"Helios is configured not to generate Export.lua stub for {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            string exportStubPath = location.ExportStubPath;
            if (!File.Exists(exportStubPath))
            {
                // clean script folder, we can just write our default stub
                FileUtility.WriteFile(exportStubPath, _exportStub);
                report.Add(new StatusReportItem
                {
                    Status = $"Wrote new Export.lua stub to {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            string contents = FileUtility.ReadFile(exportStubPath);
            if (contents == _exportStub)
            {
                // file was written by us and is still unchanged
                report.Add(new StatusReportItem
                {
                    Status = $"Export.lua stub is up to date for {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            if (ExportLuaHandling == ExportFileHandling.Replace)
            {
                // force write
                BackupExportStub(location);
                FileUtility.WriteFile(exportStubPath, _exportStub);
                report.Add(new StatusReportItem
                {
                    Status = $"Wrote generated Export.lua stub to {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            if (ExportMainCall.IsMatch(contents))
            {
                // our main script is already called, no changes required
                report.Add(new StatusReportItem
                {
                    Status = $"Export.lua stub for {location.SavedGamesName} already calls {EXPORT_MAIN_NAME} and won't be modified",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            if (HeliosExport14Call.IsMatch(contents))
            {
                // change CZ style Export.lua to call new exports
                BackupExportStub(location);
                FileUtility.WriteFile(exportStubPath, contents.Replace("HeliosExport.lua", EXPORT_MAIN_NAME));
                report.Add(new StatusReportItem
                {
                    Status = $"Export.lua stub for {location.SavedGamesName} changed to call {EXPORT_MAIN_NAME}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            if (LuaExportStartCall.IsMatch(contents))
            {
                // replace entire file because we don't know how to handle it, make user do it
                BackupExportStub(location);
                FileUtility.WriteFile(exportStubPath, _exportStub);
                report.Add(new StatusReportItem
                {
                    Status = $"Replaced Export.lua stub for {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            if (DofileCall.IsMatch(contents) || HeliosDofileCall.IsMatch(contents))
            {
                // add a dofile line to a file already in that style
                BackupExportStub(location);
                FileUtility.WriteFile(exportStubPath,
                    $"{contents}{Environment.NewLine}dofile(lfs.writedir()..[[{location.ExportMainRelativePath(EXPORT_MAIN_NAME)}]]){Environment.NewLine}");
                report.Add(new StatusReportItem
                {
                    Status = $"Added call to {EXPORT_MAIN_NAME} to existing Export.lua stub for {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });
                return;
            }

            // NOTE: we should never get here if the code is correct
            report.Add(new StatusReportItem
            {
                Status = $"Export.lua stub for {location.SavedGamesName} cannot be updated because it is not understood by Helios",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            });
        }

        private static void BackupExportStub(InstallationLocation location)
        {
            string dateStamp = DateTime.Now.ToString("yyyyMMdd", DateTimeFormatInfo.InvariantInfo);
            // even for debugging, only create this many backups in one day to guard against program error creating them in a loop
            for (int counter = 0; counter < 10; counter++)
            {
                string suffix = counter > 0 ? $".{counter}" : "";
                string backupPath = Path.Combine(location.ScriptDirectoryPath, $"Export.lua.backup.{dateStamp}{suffix}.txt");
                if (!File.Exists(backupPath))
                {
                    AddCommentAndCopyLua(location.ExportStubPath, backupPath);
                    return;
                }
            }
            string lastResortPath = Path.Combine(location.ScriptDirectoryPath, $"Export.lua.backup.{dateStamp}.overflow.txt");
            if (File.Exists(lastResortPath))
            {
                File.Delete(lastResortPath);
            }
            AddCommentAndCopyLua(location.ExportStubPath, lastResortPath);
        }

        private static void AddCommentAndCopyLua(string sourcePath, string backupPath)
        {
            string contents = FileUtility.ReadFile(sourcePath);
            string modified = $"-- backup copy of {Path.GetFileName(sourcePath)} created by Helios{Environment.NewLine}{Environment.NewLine}{contents}";
            FileUtility.WriteFile(backupPath, modified);
        }

        private bool AuthorizeExportStubChanges(IInstallationCallbacks callbacks, HashSet<string> considered, InstallationLocation location)
        {
            if (ExportLuaHandling == ExportFileHandling.Ignore)
            {
                // we are not going to write Export.lua
                return true;
            }

            string exportStubPath = location.ExportStubPath;
            if (considered.Contains(exportStubPath))
            {
                // already asked about this one
                return true;
            }
            considered.Add(exportStubPath);

            if (!File.Exists(exportStubPath))
            {
                // clean script folder, we can just write our default stub
                return true;
            }

            string contents = FileUtility.ReadFile(exportStubPath);
            if (contents == _exportStub)
            {
                // file was written by us and is still unchanged
                return true;
            }

            InstallationPromptResult response;
            if (ExportLuaHandling == ExportFileHandling.Replace)
            {
                response = callbacks.DangerPrompt("Replace Export.lua",
                    $"Helios is about to overwrite the Export.lua script \nat {exportStubPath}.\nHelios is configured to generate this entire file including any third party dofile lines. A backup copy of this file will be left in the same folder.  You can also configure Helios to just update the file if you want to make changes yourself.",
                    new List<StatusReportItem>());
            }
            else if (ExportMainCall.IsMatch(contents))
            {
                // our main script is already called, no changes required
                return true;
            }
            else if (HeliosExport14Call.IsMatch(contents))
            {
                response = callbacks.DangerPrompt("Upgrade Export.lua",
                    $"Helios is about to change the Export.lua script \nat {exportStubPath}\nto call the new main export script {EXPORT_MAIN_NAME}.  A backup copy of this file will be left in the same folder.",
                    new List<StatusReportItem>());
            }
            else if (LuaExportStartCall.IsMatch(contents))
            {
                response = callbacks.DangerPrompt("Overwrite Export.lua",
                    $"Helios is about to overwrite the Export.lua script \nat {exportStubPath}.\nThis file could have been created by third party software or a previous version and it appears to be a complete export file, such as created by Helios 1.4.  This version of Helios requires an Export.lua stub file with dofile(...) calls in it to be combined with other applications requiring exports.  Helios will overwrite this file and you will need to add support for third party scripts to it yourself.  A backup copy of this file will be left in the same folder.",
                    new List<StatusReportItem>());
            }
            else if (DofileCall.IsMatch(contents) || HeliosDofileCall.IsMatch(contents))
            {
                response = callbacks.DangerPrompt("Configure Export.lua",
                    $"Helios is about add a line to the Export.lua script \nat {exportStubPath}.\nThis line will call the main export script {EXPORT_MAIN_NAME} to allow sending data to Helios.  A backup copy of this file will be left in the same folder.",
                    new List<StatusReportItem>());
            }
            else
            {
                callbacks.Failure("Unrecognized Export.lua",
                    $"Helios cannot understand the Export.lua script\nat {exportStubPath}.\nIn order to install this version of Helios, you will need to rename this script and then configure this interface again.  Afterwards, you can edit this file again to add your changes.  Alternatively, you can configure Helios not to create Export.lua at all if you have an unusual Export.lua that works with this version of Helios.",
                    new StatusReportItem
                    {
                        Status = "The contents of this file did not match any of the patterns we recognize",
                        Code = contents,
                        Severity = StatusReportItem.SeverityCode.Warning
                    }.AsReport());
                return false;
            }
            return (response != InstallationPromptResult.Cancel);
        }

        /// <summary>
        /// utility for checking if everything is up to date while editing in the UI,
        /// which is not the same as performing the ready check at run time
        /// </summary>
        /// <returns></returns>
        internal IList<StatusReportItem> CheckConfig()
        {
            List<StatusReportItem> report = new List<StatusReportItem>();

            // check if we are running on the same machine providing the exports
            if (Locations.IsRemote)
            {
                report.Add(new StatusReportItem
                {
                    Status =
                        $"This computer is configured as a remote Helios, so it is not the machine where DCS runs.  Helios cannot generate export files or check that they have been correctly copied to the computer running DCS.",
                    Recommendation =
                        "Also generate your Helios configuration on the computer running DCS to make sure all export scripts are installed",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                });

                // do not perform any of the remaining checks, because they make no sense remotely
                return report;
            }

            // report all locations but only retain the enabled ones
            IList<InstallationLocation> installationLocations = InstallationLocations.Singleton.Items
                .Select(location =>
                {
                    report.Add(ReportLocation(location));
                    return location;
                })
                .Where(location => location.IsEnabled)
                .ToList();

            if (!installationLocations.Any())
            {
                report.Add(new StatusReportItem
                {
                    Status = "No DCS installation locations are configured for exports configuration",
                    Recommendation = "Configure any DCS installation directories you use",
                    Severity = StatusReportItem.SeverityCode.Error
                });
                Status = StatusCodes.NoLocations;
                return report;
            }

            // export.lua generation is optional, so we have to pick the correct function to check it
            Func<InstallationLocation, StatusReportItem> stubChecker = SelectStubChecker();

            foreach (InstallationLocation location in installationLocations)
            {
                List<Func<InstallationLocation, StatusReportItem>> checks =
                    new List<Func<InstallationLocation, StatusReportItem>>
                    {
                        CheckDirectories, stubChecker, CheckExportScript, CheckModule
                    };

                StatusCodes tempStatus = StatusCodes.UpToDate;
                foreach (StatusReportItem result in checks.Select(check => check(location)))
                {
                    report.Add(result);
                    if (result.Flags.HasFlag(StatusReportItem.StatusFlags.ConfigurationUpToDate))
                    {
                        continue;
                    }

                    Logger.Debug(result.Status);
                    tempStatus = StatusCodes.OutOfDate;
                }

                foreach (StatusReportItem result in CheckImpersonationModules(location))
                {
                    report.Add(result);
                    if (result.Flags.HasFlag(StatusReportItem.StatusFlags.ConfigurationUpToDate))
                    {
                        continue;
                    }
                    Logger.Debug(result.Status);
                    tempStatus = StatusCodes.OutOfDate;
                }
                Status = tempStatus;
                return report;
            }
            // finished
            Status = StatusCodes.UpToDate;
            return report;
        }

        private Func<InstallationLocation, StatusReportItem> SelectStubChecker()
        {
            Func<InstallationLocation, StatusReportItem> stubChecker;
            switch (ExportLuaHandling)
            {
                case ExportFileHandling.Update:
                    stubChecker = CheckUpdatedExportStub;
                    break;
                case ExportFileHandling.Replace:
                    stubChecker = CheckGeneratedExportStub;
                    break;
                case ExportFileHandling.Ignore:
                    stubChecker = CheckThirdPartyExportStub;
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            return stubChecker;
        }

        private static StatusReportItem ReportLocation(InstallationLocation location)
        {
            string statusPrefix = location.IsEnabled ? "" : "Not writing to ";
            return new StatusReportItem
            {
                Status =
                    $"{statusPrefix}DCS version {location.Version} installed at '{location.Path}' with Saved Games at '{location.SavedGamesPath}'",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
            };
        }

        /// <summary>
        /// main entry point for run time readiness check with a human readable narrative
        /// </summary>
        /// <returns></returns>
        public override IEnumerable<StatusReportItem> PerformReadyCheck()
        {
            string reportingName = _parent.ImpersonatedVehicleName ?? _parent.VehicleName;

            // check if we are running on the same machine where the export scripts need to be installed
            if (Locations.IsRemote)
            {
                yield return new StatusReportItem
                {
                    Status =
                        $"This computer is configured as a remote Helios, so it is not the machine where DCS runs.  Helios cannot check that export files have been correctly copied to the computer running DCS.",
                    Recommendation =
                        "Check your Helios configuration on the computer running DCS to make sure all export scripts are installed",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate,
                    Link = StatusReportItem.ProfileEditor
                };

                // do not perform any of the remaining checks, because they make no sense remotely
                yield break;
            }

            // report all locations but only retain the enabled ones
            IList<InstallationLocation> installationLocations = new List<InstallationLocation>();
            foreach (InstallationLocation location in InstallationLocations.Singleton.Items)
            {
                yield return ReportLocation(location);
                if (location.IsEnabled)
                {
                    installationLocations.Add(location);
                }
            }

            if (!installationLocations.Any())
            {
                yield return new StatusReportItem
                {
                    Status = "No DCS installation locations are configured for exports configuration",
                    Recommendation = "Configure any DCS installation directories you use",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
            foreach (InstallationLocation location in installationLocations)
            {
                // check on the Export.lua stub
                UpdateExportStub();
                yield return SelectStubChecker()(location);

                // check on our main script
                UpdateExportScript();
                yield return CheckExportScript(location);

                // check if module file is even used by this interface
                if (!moduleInfo.UsesModuleFile)
                {
                    // nothing to check
                    continue;
                }

                // check on module file
                if ((!_parent.HasEmbeddedModule) && (!moduleInfo.CanGenerate))
                {
                    yield return new StatusReportItem
                    {
                        Status = $"DCS exports for {reportingName} are provided by a third party export module",
                        Recommendation = "Please manually check that the export module was correctly placed",
                        Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                    };
                    if (reportingName != _parent.VehicleName)
                    {
                        yield return new StatusReportItem
                        {
                            Status =
                                $"DCS Interface for {reportingName} requires a module that maps to the {_parent.VehicleName} interface",
                            Recommendation = "Please manually check that you are using an appropriate export module",
                            Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                        };
                    }
                }
                else
                {
                    UpdateModule();
                    yield return CheckModule(location);
                    foreach(StatusReportItem result in CheckImpersonationModules(location))
                    {
                        yield return result;
                    }
                }
            }
        }

        #region ExportGenerators

        private void UpdateDirectories()
        {
            // this does nothing, directories are created when we write
        }

        private void UpdateExportStub()
        {
            _exportStub =
                LoadDefaultExportStub()
                + string.Join("\n", GenerateDoFileLines());
        }

        private static string LoadDefaultExportStub()
        {
            return Resources.ReadResourceFile(
                "pack://application:,,,/Helios;component/Interfaces/DCS/Common/Export.lua");
        }

        private void UpdateExportScript()
        {
            string overridePath = Path.Combine(ConfigManager.DocumentPath, "Scripts", "Helios", EXPORT_MAIN_NAME);
            string exportMainRaw = File.Exists(overridePath) ? 
                File.ReadAllText(overridePath) : 
                Resources.ReadResourceFile($"pack://application:,,,/Helios;component/Interfaces/DCS/Common/{EXPORT_MAIN_NAME}");

            _exportMain = exportMainRaw
                // REVISIT: validate the IP address against allowable protocol versions and address types for this version of HeliosExport__.lua
                .Replace("HELIOS_REPLACE_IPAddress", IPAddress)
                .Replace("HELIOS_REPLACE_Port", Port.ToString())
                .Replace("HELIOS_REPLACE_ExportInterval", Math.Round(1d / Math.Max(4, ExportFrequency), 3).ToString(CultureInfo.InvariantCulture));
        }

        private void UpdateModule()
        {
            ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
            if (moduleInfo.CanBeAttached && _parent.HasEmbeddedModule)
            {
                // nothing to do
                return;
            }

            if (!moduleInfo.CanGenerate)
            {
                // not allowed
                return;
            }

            // otherwise, try to generate the module text
            switch (_parent.ExportModuleFormat)
            {
                case DCSExportModuleFormat.HeliosDriver16:
                    if (_parent is SoftInterface softInterface)
                    {
                        if (softInterface.ImpersonatedVehicles.Count() > 1)
                        {
                            _parent.ImpersonatedVehicleName = _parent.Name;
                            _exportImpersonationModuleText =
                                string.Join(Environment.NewLine, GenerateImpersonationLines())
                                + Resources.ReadResourceFile($"pack://application:,,,/Helios;component/Interfaces/DCS/Common/HeliosImpersonationExport.lua")
                                + $"{Environment.NewLine}return driver";
                        }
                    }

                    _exportModuleText =
                        string.Join(Environment.NewLine, GenerateDriverLines())
                        + FetchExportFunctions()
                        + $"{Environment.NewLine}return driver";
                    break;
                case DCSExportModuleFormat.CaptZeenModule1:
                    // don't know how
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private string GenerateElement(DCSDataElement element)
        {
            string luaTableIndex = element.ID;
            if (int.TryParse(luaTableIndex, out int numericValue) 
                && numericValue > 0
                && numericValue < 10000)
            {
                // use integer index, which is faster in Lua
                // so don't quote the index
            }
            else
            {
                // use string index
                luaTableIndex = $"\"{luaTableIndex}\"";
            }
            return $"[{luaTableIndex}]=\"{element.Format}\"";
        }

        /// <summary>
        /// generates the export format strings for any DCS functions that export something
        /// </summary>
        /// <param name="everyFrame"></param>
        /// <returns></returns>
        private IEnumerable<string> GenerateFunctions(bool everyFrame)
        {
            return SelectElements(everyFrame)
                .OrderBy(element => element.ID.Length)
                .ThenBy(element => element.ID)
                .Select(GenerateElement);
        }

        /// <summary>
        /// finds all the DCS elements that match the export frequency given
        /// </summary>
        /// <param name="everyFrame"></param>
        /// <returns></returns>
        private IEnumerable<DCSDataElement> SelectElements(bool everyFrame)
        {
            // NOTE: we could convert this to a linq expression, but these loops may be more understandable
            // ReSharper disable once LoopCanBeConvertedToQuery
            foreach (NetworkFunction function in _parent.Functions)
            {
                foreach (DCSDataElement dcsElement in function.DataElements
                    .OfType<DCSDataElement>()
                    .Where(element => element.Format != null)
                    .Where(element => element.IsExportedEveryFrame == everyFrame))
                {
                    yield return dcsElement;
                }
            }
        }

        private IEnumerable<string> GenerateDriverLines()
        {
            string reportingName = _parent.ImpersonatedVehicleName ?? _parent.VehicleName;

            yield return $"-- export driver for {reportingName} generated by Helios Profile Editor";
            yield return "local driver = { }";
            yield return $"driver.selfName = \"{reportingName}\"";
            yield return "driver.everyFrameArguments = {";
            yield return $"  {string.Join($",{Environment.NewLine}  ", GenerateFunctions(true))}";
            yield return "}";
            yield return "driver.arguments = {";
            yield return $"  {string.Join($",{Environment.NewLine}  ", GenerateFunctions(false))}";
            yield return "}";
            yield return "";
        }

        private IEnumerable<string> GenerateImpersonationLines()
        {
            string reportingName = _parent.ImpersonatedVehicleName ?? _parent.VehicleName;

            yield return $"-- export impersonation driver for {reportingName} generated by Helios Profile Editor";
            yield return $"local impersonatorSelfName = \"{reportingName}\"";
            yield return "";
        }

        private IEnumerable<string> GenerateDoFileLines()
        {
            int index = 1;
            foreach (string dofile in DoFiles)
            {
                // generate a local to hold a reference to anything the dofile returns, to
                // ensure its lifetime and report result in case of error
                // perform check to identify absolute paths entered in the panel, but for others
                // they will be assumed to be correctly following the description on the panel which 
                // says they should be a path relative to the export.lua script.
                
                string file;
                if(System.IO.Path.GetPathRoot(dofile) == "")
                {
                    file = $"lfs.writedir()..[[{System.IO.Path.Combine("Scripts", dofile)}]]";
                } else
                {
                    file = $"[[{dofile}]]";
                }
                yield return $"local helios_dofile_{index} = {{ }}";
                yield return $"helios_dofile_{index}.success, helios_dofile_{index}.result = pcall(dofile, {file})";
                yield return
                    $"if not helios_dofile_{index}.success then log.write(\"HELIOS.EXPORT\", log.ERROR, string.format(\"error return from configured external %s : %s\", [['{dofile}']], tostring(helios_dofile_{index}.result))) end";
                index++;
            }
        }

        private string FetchExportFunctions()
        {
            if (string.IsNullOrWhiteSpace(_parent.ExportFunctionsPath))
            {
                return "";
            }

            try
            {
                Uri exportFunctionsUri = new Uri(_parent.ExportFunctionsPath);
                if (exportFunctionsUri.IsFile)
                {
                    if (!File.Exists(_parent.ExportFunctionsPath))
                    {
                        // this should have been detected by parent
                        Logger.Error("custom Lua export functions not found at {Path}; there will be no custom code in the associated interface", Anonymizer.Anonymize(_parent.ExportFunctionsPath));
                        return "";
                    }

                    // this is allowed only for export functions, other resources must be read from compiled packs, which is
                    // why ReadResourceFile does not allow this case
                    return FileUtility.ReadFile(_parent.ExportFunctionsPath);
                }
                return Resources.ReadResourceFile(_parent.ExportFunctionsPath);
            }
            catch (Exception ex)
            {
                Logger.Error(ex, $"failed to load interface-specific functions for {_parent.VehicleName} from '{Anonymizer.Anonymize(_parent.ExportFunctionsPath)}'");
                throw;
            }
        }

        #endregion

        #region ExportChecks

        private StatusReportItem CheckDirectories(InstallationLocation location)
        {
            string path = location.ScriptDirectoryPath;
            if (!Directory.Exists(path))
            {
                return new StatusReportItem
                {
                    Status = $"Export scripts have not been generated for {location.SavedGamesName}",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            return new StatusReportItem
            {
                Status = $"Export scripts location for {location.SavedGamesName} exists",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckGeneratedExportStub(InstallationLocation location)
        {
            string exportLuaPath = location.ExportStubPath;
            if (!File.Exists(exportLuaPath))
            {
                return new StatusReportItem
                {
                    Status = $"The configured DCS Export.lua stub does not exist at '{exportLuaPath}'",
                    Recommendation =
                        "Configure the DCS interface or configure install location correctly to locate the file",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = FileUtility.ReadFile(exportLuaPath);
            if (!contents.Equals(_exportStub))
            {
                return new StatusReportItem
                {
                    Status = $"The DCS Export.lua stub at '{exportLuaPath}' does not match configuration",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    // survive this
                    Severity = StatusReportItem.SeverityCode.Warning
                };
            }

            return new StatusReportItem
            {
                Status = $"The configured DCS Export.lua stub at '{exportLuaPath}' is up to date",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckUpdatedExportStub(InstallationLocation location)
        {
            string exportLuaPath = location.ExportStubPath;
            if (!File.Exists(exportLuaPath))
            {
                return new StatusReportItem
                {
                    Status = $"The configured DCS Export.lua stub does not exist at '{exportLuaPath}'",
                    Recommendation =
                        "Configure the DCS interface or configure install location correctly to locate the file",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = FileUtility.ReadFile(exportLuaPath);

            if (contents == _exportStub)
            {
                // file was written by us and is still unchanged
                return new StatusReportItem
                {
                    Status = $"Generated Export.lua stub is up to date for {location.SavedGamesName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            if (ExportMainCall.IsMatch(contents))
            {
                // our main script is already called, no changes required
                return new StatusReportItem
                {
                    Status = $"Export.lua stub for {location.SavedGamesName} calls {EXPORT_MAIN_NAME}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            if (HeliosExport14Call.IsMatch(contents))
            {
                // CZ style Export.lua
                return new StatusReportItem
                {
                    Status = $"Export.lua stub for {location.SavedGamesName} looks like a Helios 1.4 stub that needs an upgrade",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            if (LuaExportStartCall.IsMatch(contents))
            {
                // we don't know how to check this type of script that is not a stub
                return new StatusReportItem
                {
                    Status = $"Export.lua for {location.SavedGamesName} looks like a complete export script that needs an upgrade",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            if (DofileCall.IsMatch(contents))
            {
                // need to add a dofile line to a file already in that style
                return new StatusReportItem
                {
                    Status = $"Export.lua stub for {location.SavedGamesName} does not call {EXPORT_MAIN_NAME}",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // no idea what this is
            return new StatusReportItem
            {
                Status = $"Export.lua for {location.SavedGamesName} cannot be understood by Helios",
                Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup for more instructions",
                Severity = StatusReportItem.SeverityCode.Error
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckThirdPartyExportStub(InstallationLocation location)
        {
            string exportLuaPath = location.ExportStubPath;
            if (!File.Exists(exportLuaPath))
            {
                return new StatusReportItem
                {
                    Status = $"The Export.lua stub does not exist at '{exportLuaPath}'",
                    Recommendation = "Generate Export.lua or create it manually",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error,
                    // writing updates won't fix this
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            string contents = FileUtility.ReadFile(exportLuaPath);
            if (!contents.Contains(EXPORT_MAIN_NAME))
            {
                return new StatusReportItem
                {
                    Status =
                        $"Helios Export script Helios\\{EXPORT_MAIN_NAME} does not appear to be called by Export.lua at '{exportLuaPath}'",
                    Recommendation = "Recreate Export.lua or edit it manually",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error,
                    // writing updates won't fix this
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            return new StatusReportItem
            {
                Status = $"The Export.lua stub at '{exportLuaPath}' is not generated by Helios",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckExportScript(InstallationLocation location)
        {
            string mainPath = location.ExportMainPath(EXPORT_MAIN_NAME);
            if (!File.Exists(mainPath))
            {
                return new StatusReportItem
                {
                    Status = $"The configured DCS export script does not exist at '{mainPath}'",
                    Recommendation =
                        "Configure the DCS interface or configure install locations correctly to locate the file",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = FileUtility.ReadFile(mainPath);
            if (!contents.Equals(_exportMain))
            {
                return new StatusReportItem
                {
                    Status = $"The DCS export script at '{mainPath}' does not match configuration",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            return new StatusReportItem
            {
                Status = $"The configured DCS export script at '{mainPath}' is up to date",
                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
            };
        }

        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private StatusReportItem CheckModule(InstallationLocation location)
        {
            if ((_parent.ImpersonatedVehicleName ?? _parent.VehicleName) == null)
            {
                // this will happen when Generic or similar interface is not configured completely
                return new StatusReportItem
                {
                    Status = $"Vehicle name must be configured for interfaces that can be used for different vehicles.",
                    Recommendation = $"Configure vehicle name for {_parent.Name}",
                    Severity = StatusReportItem.SeverityCode.Error,
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate,
                    Link = StatusReportItem.ProfileEditor
                };
            }

            ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];

            // check if module file is even used by this interface
            if (!moduleInfo.UsesModuleFile)
            {
                // nothing to check
                return new StatusReportItem
                {
                    Status = $"{moduleInfo.DisplayName} does not require a module file to be written by Helios.",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
                };
            }

            // check on module file

            if (!moduleInfo.IsAllowedToWrite)
            {
                // no module file at all
                return new StatusReportItem
                {
                    Status = $"The {moduleInfo.DisplayName} does not use a module or driver file",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
                };
            }

            if ((!_parent.HasEmbeddedModule) && (!moduleInfo.CanGenerate))
            {
                // no included module and we don't even know its name
                return new StatusReportItem
                {
                    Status = $"The {moduleInfo.DisplayName} is not included in this profile, so Helios cannot check if it is installed.",
                    Recommendation = "Please manually check that the export module was correctly placed",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            string exportModulePath = location.ExportModulePath(moduleInfo.ModuleLocation, _parent.WrittenModuleBaseName);
            if (!File.Exists(exportModulePath))
            {
                return new StatusReportItem
                {
                    Status = $"The {moduleInfo.DisplayName} does not exist at '{exportModulePath}'",
                    Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                    Link = StatusReportItem.ProfileEditor,
                    Severity = StatusReportItem.SeverityCode.Error
                };
            }

            // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
            string contents = FileUtility.ReadFile(exportModulePath);
            if (string.IsNullOrEmpty(_exportModuleText) || contents.Equals(_exportModuleText))
            {
                return new StatusReportItem
                {
                    Status = $"The {moduleInfo.DisplayName} at '{exportModulePath}' is up to date",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }

            return new StatusReportItem
            {
                Status =
                    $"The {moduleInfo.DisplayName} at '{exportModulePath}' does not match configuration",
                Recommendation = $"Select the interface for {_parent.VehicleName} and run DCS setup",
                Link = StatusReportItem.ProfileEditor,
                Severity = StatusReportItem.SeverityCode.Error
            };

 
        }
        // NOTE: we don't factor this to share code with the other Check... functions because they are all
        // subtly different in terms of severity and we want to encourage more special cases added in the future
        private IEnumerable<StatusReportItem> CheckImpersonationModules(InstallationLocation location)
        {
            ModuleFormatInfo moduleInfo = ExportModuleFormatInfo[_parent.ExportModuleFormat];
            if (_parent is SoftInterface softInterface && softInterface.ImpersonatedVehicles.Count > 0) {
                foreach(string vehicle in softInterface.ImpersonatedVehicles)
                {
                    // check if module file is even used by this interface
                    if (!moduleInfo.UsesModuleFile)
                    {
                        // nothing to check
                        yield return new StatusReportItem
                        {
                            Status = $"{moduleInfo.DisplayName} does not require a module file to be written by Helios.",
                            Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
                        };
                    }
                    else
                    {
                        // check on module file

                        if (!moduleInfo.IsAllowedToWrite)
                        {
                            // no module file at all
                            yield return new StatusReportItem
                            {
                                Status = $"The {moduleInfo.DisplayName} does not use a module or driver file",
                                Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate | StatusReportItem.StatusFlags.Verbose
                            };
                        }
                        else
                        {
                            if ((!_parent.HasEmbeddedModule) && (!moduleInfo.CanGenerate))
                            {
                                // no included module and we don't even know its name
                                yield return new StatusReportItem
                                {
                                    Status = $"The {moduleInfo.DisplayName} is not included in this profile, so Helios cannot check if it is installed.",
                                    Recommendation = "Please manually check that the export module was correctly placed",
                                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                                };
                            }
                            else
                            {
                                string exportImpersonationModulePath = location.ExportModulePath(moduleInfo.ModuleLocation, vehicle);
                                if (!File.Exists(exportImpersonationModulePath))
                                {
                                    yield return new StatusReportItem
                                    {
                                        Status = $"A part of the {moduleInfo.DisplayName} does not exist at '{exportImpersonationModulePath}'",
                                        Recommendation = $"Select the interface for {_parent.Name} and run DCS setup",
                                        Link = StatusReportItem.ProfileEditor,
                                        Severity = StatusReportItem.SeverityCode.Error
                                    };
                                }
                                else
                                {
                                    // NOTE: we have the entire contents we expect in this file in memory, so there is no point in hashing this
                                    string contents = FileUtility.ReadFile(exportImpersonationModulePath);
                                    if (string.IsNullOrEmpty(_exportImpersonationModuleText) || contents.Equals(_exportImpersonationModuleText))
                                    {
                                        yield return new StatusReportItem
                                        {
                                            Status = $"The {moduleInfo.DisplayName} at '{exportImpersonationModulePath}' is up to date",
                                            Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                                        };
                                    }
                                    else
                                    {
                                        yield return new StatusReportItem
                                        {
                                            Status =
                                            $"The {moduleInfo.DisplayName} at '{exportImpersonationModulePath}' does not match configuration",
                                            Recommendation = $"Select the interface for {_parent.Name} and run DCS setup",
                                            Link = StatusReportItem.ProfileEditor,
                                            Severity = StatusReportItem.SeverityCode.Error,
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

            } else
            {
                yield return new StatusReportItem
                {
                    Status =
                    $"There are no vehicles being impersonated by the {moduleInfo.DisplayName} interface for {_parent.VehicleName}",
                    Flags = StatusReportItem.StatusFlags.ConfigurationUpToDate
                };
            }
        }
        #endregion

        #region Uninstall

        /// <summary>
        /// Try to remove our Export.lua hooks from all known DCS installations, whether currently enabled or not.
        /// Interaction with the user is not possible and the function must just do a best effort.
        /// </summary>
        public static void RemoveExportLuaHooks()
        {
            // WARNING: this function is called by the installer and can neither log nor communicate with the user
            string defaultStub = LoadDefaultExportStub();
            HashSet<string> done = new HashSet<string>();

            foreach (InstallationLocation installationLocation in InstallationLocations.Singleton.Items)
            {
                string exportLuaPath = installationLocation.ExportStubPath;
                
                // do each file at most once
                if (done.Contains(exportLuaPath))
                {
                    continue;
                }
                done.Add(exportLuaPath);

                if (!File.Exists(exportLuaPath))
                {
                    continue;
                }

                string content = FileUtility.ReadFile(exportLuaPath);

                // if the file is a stub we wrote with no dofiles, then we can just delete it
                if (content == defaultStub)
                {
                    BackupExportStub(installationLocation);
                    File.Delete(exportLuaPath);
                    return;
                }

                // otherwise we have to edit
                Match match = ExportMainCall.Match(content);
                if (!match.Success)
                {
                    // no call to our main
                    continue;
                }

                // comment out our call
                BackupExportStub(installationLocation);
                string code = match.Groups[0].Value;
                string replacementCode = code.Replace("dofile(", $"-- following line commented out during Helios uninstall{Environment.NewLine}-- dofile(");
                string modified = content.Replace(code, replacementCode);
                FileUtility.WriteFile(exportLuaPath, modified);
            }
        }

        #endregion
    }
}